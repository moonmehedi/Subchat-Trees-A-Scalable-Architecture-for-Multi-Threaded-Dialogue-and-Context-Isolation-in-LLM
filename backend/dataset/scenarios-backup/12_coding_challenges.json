{
  "scenario_name": "Coding Challenges & Problem Solving",
  "description": "Tests retrieval of specific algorithm solutions and problem-solving approaches",
  "tree_type": "main_with_subchats",
  "conversations": [
    {
      "step": 1,
      "action": "send_message",
      "node_type": "main",
      "message": "I solved 350 LeetCode problems so far",
      "expected_response_contains": ["350", "LeetCode", "solved"]
    },
    {
      "step": 2,
      "action": "send_message",
      "node_type": "main",
      "message": "My goal is to reach 500 problems by the end of this year",
      "expected_response_contains": ["500", "goal", "year"]
    },
    {
      "step": 3,
      "action": "send_message",
      "node_type": "main",
      "message": "My favorite algorithm is Dynamic Programming",
      "expected_response_contains": ["Dynamic Programming", "favorite", "algorithm"]
    },
    {
      "step": 4,
      "action": "send_message",
      "node_type": "main",
      "message": "The hardest problem I solved was 'Median of Two Sorted Arrays' in O(log(m+n)) time",
      "expected_response_contains": ["Median of Two Sorted Arrays", "hardest", "O(log"]
    },
    {
      "step": 5,
      "action": "create_subchat",
      "parent_node": "main",
      "subchat_name": "Graph Algorithms",
      "message": "I'm really good at graph problems using DFS and BFS",
      "expected_response_contains": ["graph", "DFS", "BFS"]
    },
    {
      "step": 6,
      "action": "send_message",
      "node_type": "subchat_1",
      "message": "I can solve Dijkstra's shortest path in my sleep",
      "expected_response_contains": ["Dijkstra", "shortest path"]
    },
    {
      "step": 7,
      "action": "send_message",
      "node_type": "subchat_1",
      "message": "I also know Kruskal's and Prim's algorithms for minimum spanning tree",
      "expected_response_contains": ["Kruskal", "Prim", "spanning tree"]
    },
    {
      "step": 8,
      "action": "send_message",
      "node_type": "subchat_1",
      "message": "My favorite graph problem is detecting cycles using Union-Find",
      "expected_response_contains": ["cycles", "Union-Find", "favorite"]
    },
    {
      "step": 9,
      "action": "create_subchat",
      "parent_node": "main",
      "subchat_name": "Tree Problems",
      "message": "I love binary tree problems, especially traversal questions",
      "expected_response_contains": ["binary tree", "traversal", "love"]
    },
    {
      "step": 10,
      "action": "send_message",
      "node_type": "subchat_2",
      "message": "I can do inorder, preorder, and postorder traversal both recursively and iteratively",
      "expected_response_contains": ["inorder", "preorder", "postorder", "recursively"]
    },
    {
      "step": 11,
      "action": "send_message",
      "node_type": "subchat_2",
      "message": "My trick for iterative traversal is using a stack for DFS",
      "expected_response_contains": ["stack", "DFS", "trick"]
    },
    {
      "step": 12,
      "action": "switch_to_node",
      "node_type": "main",
      "message": "How many LeetCode problems have I solved?",
      "expected_response_contains": ["350"],
      "should_retrieve": true,
      "expected_retrieval": ["350 LeetCode"],
      "should_not_contain": ["Dijkstra", "Union-Find", "stack"]
    },
    {
      "step": 13,
      "action": "send_message",
      "node_type": "main",
      "message": "What's my favorite algorithm?",
      "expected_response_contains": ["Dynamic Programming"],
      "should_retrieve": true,
      "expected_retrieval": ["Dynamic Programming"]
    },
    {
      "step": 14,
      "action": "switch_to_node",
      "node_type": "subchat_1",
      "message": "What's my favorite graph problem?",
      "expected_response_contains": ["cycles", "Union-Find"],
      "should_retrieve": true,
      "expected_retrieval": ["detecting cycles", "Union-Find"],
      "should_not_contain": ["350", "Dynamic Programming", "binary tree"]
    }
  ]
}
